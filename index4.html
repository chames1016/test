<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>俄羅斯方塊 - 正確旋轉版</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #1a1a1a;
            color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 900px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        h1 {
            color: #FFD700;
            font-size: 2.5rem;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            margin-bottom: 10px;
        }
        
        .game-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
            width: 100%;
        }
        
        .game-board {
            background-color: #FFD700;
            border: 3px solid #FFA500;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.3);
        }
        
        canvas {
            display: block;
        }
        
        .side-panel {
            flex: 1;
            min-width: 250px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .info-box {
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #444;
        }
        
        .score-value {
            font-size: 3rem;
            font-weight: bold;
            color: #4CAF50;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .game-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        button {
            background-color: #444;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
        }
        
        button:hover {
            background-color: #555;
            transform: translateY(-2px);
        }
        
        .start-btn { background-color: #4CAF50; }
        .start-btn:hover { background-color: #45a049; }
        .pause-btn { background-color: #FF9800; }
        .pause-btn:hover { background-color: #e68900; }
        .restart-btn { background-color: #2196F3; }
        .restart-btn:hover { background-color: #0b7dda; }
        
        .rotate-controls {
            margin-top: 10px;
            text-align: center;
        }
        
        .rotate-btn {
            background-color: #9C27B0;
            margin: 5px;
            padding: 10px 15px;
        }
        
        .rotate-btn:hover {
            background-color: #7B1FA2;
        }
        
        .game-status {
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            background-color: #222;
            margin-top: 10px;
        }
        
        .status-ready { color: #4CAF50; }
        .status-playing { color: #FFD700; }
        .status-paused { color: #FF9800; }
        .status-gameover { color: #f44336; }
        
        .instructions {
            margin-top: 10px;
        }
        
        .instructions h3 {
            color: #FFD700;
            margin-bottom: 10px;
        }
        
        .instructions ul {
            list-style-type: none;
        }
        
        .instructions li {
            margin-bottom: 8px;
            color: #ccc;
        }
        
        .instructions .key {
            display: inline-block;
            background-color: #555;
            padding: 4px 10px;
            border-radius: 5px;
            margin: 0 5px;
            font-family: monospace;
            color: #FFD700;
        }
        
        footer {
            margin-top: 30px;
            text-align: center;
            color: #666;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>俄羅斯方塊 - 旋轉版</h1>
            <p>每個方塊顏色不同，按A/D鍵旋轉90度</p>
        </header>
        
        <div class="game-area">
            <div>
                <canvas class="game-board" id="gameCanvas" width="300" height="600"></canvas>
            </div>
            
            <div class="side-panel">
                <div class="info-box">
                    <div class="score-value" id="score">0</div>
                    
                    <div class="controls">
                        <div class="game-controls">
                            <button class="start-btn" id="startBtn">開始遊戲</button>
                            <button class="pause-btn" id="pauseBtn">暫停遊戲</button>
                            <button class="restart-btn" id="restartBtn">重新開始</button>
                        </div>
                        
                        <div class="rotate-controls">
                            <button class="rotate-btn" id="rotateLeft">左旋轉 (A鍵)</button>
                            <button class="rotate-btn" id="rotateRight">右旋轉 (D鍵)</button>
                        </div>
                        
                        <div class="game-status">
                            狀態: <span id="gameStatus" class="status-ready">準備開始</span>
                        </div>
                    </div>
                </div>
                
                <div class="info-box instructions">
                    <h3>遊戲控制</h3>
                    <ul>
                        <li><span class="key">←</span> 左移方塊</li>
                        <li><span class="key">→</span> 右移方塊</li>
                        <li><span class="key">↓</span> 加速下落</li>
                        <li><span class="key">A</span> 向左旋轉90度</li>
                        <li><span class="key">D</span> 向右旋轉90度</li>
                        <li><span class="key">Space</span> 直接落下</li>
                        <li><span class="key">P</span> 暫停/繼續遊戲</li>
                    </ul>
                    <p style="color: #FF9800; margin-top: 10px;">旋轉功能讓您更容易擺放方塊！</p>
                </div>
            </div>
        </div>
        
        <footer>
            <p>俄羅斯方塊遊戲 | 每個方塊顏色不同 | 支援旋轉功能</p>
        </footer>
    </div>

    <script>
        // 遊戲變數
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const gameStatusElement = document.getElementById('gameStatus');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const restartBtn = document.getElementById('restartBtn');
        const rotateLeftBtn = document.getElementById('rotateLeft');
        const rotateRightBtn = document.getElementById('rotateRight');
        
        // 方塊形狀定義
        const tetrominoes = [
            // I
            [
                [0,0,0,0],
                [1,1,1,1],
                [0,0,0,0],
                [0,0,0,0]
            ],
            // J
            [
                [1,0,0],
                [1,1,1],
                [0,0,0]
            ],
            // L
            [
                [0,0,1],
                [1,1,1],
                [0,0,0]
            ],
            // O
            [
                [1,1],
                [1,1]
            ],
            // S
            [
                [0,1,1],
                [1,1,0],
                [0,0,0]
            ],
            // T
            [
                [0,1,0],
                [1,1,1],
                [0,0,0]
            ],
            // Z
            [
                [1,1,0],
                [0,1,1],
                [0,0,0]
            ]
        ];
        
        // 遊戲參數
        const ROWS = 20;
        const COLS = 10;
        const BLOCK_SIZE = canvas.width / COLS;
        
        let board = [];
        let currentPiece = null;
        let currentPieceColor = null;
        let score = 0;
        let gameRunning = false;
        let gameOver = false;
        let dropInterval = 1000;
        let dropStart = Date.now();
        let gameLoop;
        
        // 初始化遊戲板
        function initBoard() {
            board = [];
            for (let r = 0; r < ROWS; r++) {
                board[r] = [];
                for (let c = 0; c < COLS; c++) {
                    board[r][c] = null;
                }
            }
        }
        
        // 生成隨機顏色
        function generateRandomColor() {
            const colors = [
                '#FF5252', '#FF4081', '#E040FB', '#7C4DFF',
                '#536DFE', '#448AFF', '#40C4FF', '#18FFFF',
                '#64FFDA', '#69F0AE', '#B2FF59', '#EEFF41',
                '#FFFF00', '#FFD740', '#FFAB40', '#FF6E40'
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        }
        
        // 創建新方塊
        function createPiece() {
            const pieceIndex = Math.floor(Math.random() * tetrominoes.length);
            currentPiece = {
                shape: JSON.parse(JSON.stringify(tetrominoes[pieceIndex])),
                row: 0,
                col: Math.floor(COLS / 2) - Math.floor(tetrominoes[pieceIndex][0].length / 2)
            };
            currentPieceColor = generateRandomColor();
            
            // 檢查遊戲是否結束
            if (checkCollision(0, 0)) {
                gameOver = true;
                updateGameStatus('遊戲結束');
                clearInterval(gameLoop);
            }
        }
        
        // 繪製遊戲板
        function drawBoard() {
            // 繪製黃色背景
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 繪製網格線
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
            ctx.lineWidth = 1;
            
            // 垂直線
            for (let c = 0; c <= COLS; c++) {
                ctx.beginPath();
                ctx.moveTo(c * BLOCK_SIZE, 0);
                ctx.lineTo(c * BLOCK_SIZE, canvas.height);
                ctx.stroke();
            }
            
            // 水平線
            for (let r = 0; r <= ROWS; r++) {
                ctx.beginPath();
                ctx.moveTo(0, r * BLOCK_SIZE);
                ctx.lineTo(canvas.width, r * BLOCK_SIZE);
                ctx.stroke();
            }
            
            // 繪製已固定的方塊
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c]) {
                        ctx.fillStyle = board[r][c];
                        ctx.fillRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                        
                        // 添加內部效果
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                        ctx.fillRect(c * BLOCK_SIZE + 2, r * BLOCK_SIZE + 2, BLOCK_SIZE - 5, BLOCK_SIZE - 5);
                    }
                }
            }
        }
        
        // 繪製當前方塊
        function drawPiece() {
            if (!currentPiece) return;
            
            const shape = currentPiece.shape;
            
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        ctx.fillStyle = currentPieceColor;
                        ctx.fillRect(
                            (currentPiece.col + c) * BLOCK_SIZE,
                            (currentPiece.row + r) * BLOCK_SIZE,
                            BLOCK_SIZE - 1,
                            BLOCK_SIZE - 1
                        );
                        
                        // 添加內部效果
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                        ctx.fillRect(
                            (currentPiece.col + c) * BLOCK_SIZE + 2,
                            (currentPiece.row + r) * BLOCK_SIZE + 2,
                            BLOCK_SIZE - 5,
                            BLOCK_SIZE - 5
                        );
                    }
                }
            }
        }
        
        // 繪製遊戲
        function draw() {
            drawBoard();
            drawPiece();
        }
        
        // 檢查碰撞
        function checkCollision(rowOffset = 0, colOffset = 0) {
            if (!currentPiece) return false;
            
            const shape = currentPiece.shape;
            
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (!shape[r][c]) continue;
                    
                    const newRow = currentPiece.row + r + rowOffset;
                    const newCol = currentPiece.col + c + colOffset;
                    
                    // 檢查是否超出邊界或與已固定的方塊重疊
                    if (
                        newCol < 0 || 
                        newCol >= COLS || 
                        newRow >= ROWS || 
                        (newRow >= 0 && board[newRow][newCol])
                    ) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        // 旋轉方塊90度
        function rotatePiece(clockwise = true) {
            if (!currentPiece || !gameRunning || gameOver) return false;
            
            // 儲存原始狀態
            const originalShape = JSON.parse(JSON.stringify(currentPiece.shape));
            const originalRow = currentPiece.row;
            const originalCol = currentPiece.col;
            
            // 創建新形狀（旋轉90度）
            const rows = currentPiece.shape.length;
            const cols = currentPiece.shape[0].length;
            let newShape = [];
            
            if (clockwise) {
                // 順時針旋轉90度
                for (let c = 0; c < cols; c++) {
                    newShape[c] = [];
                    for (let r = rows - 1; r >= 0; r--) {
                        newShape[c][rows - 1 - r] = currentPiece.shape[r][c];
                    }
                }
            } else {
                // 逆時針旋轉90度
                for (let c = cols - 1; c >= 0; c--) {
                    newShape[cols - 1 - c] = [];
                    for (let r = 0; r < rows; r++) {
                        newShape[cols - 1 - c][r] = currentPiece.shape[r][c];
                    }
                }
            }
            
            // 更新形狀
            currentPiece.shape = newShape;
            
            // 調整位置（確保旋轉後不會超出邊界）
            if (currentPiece.col + newShape[0].length > COLS) {
                currentPiece.col = COLS - newShape[0].length;
            }
            
            if (currentPiece.col < 0) {
                currentPiece.col = 0;
            }
            
            // 檢查旋轉後是否碰撞
            if (checkCollision()) {
                // 嘗試牆壁踢（wall kick）
                let kickOffsets = [
                    [0, 0], [0, -1], [0, 1], [-1, 0], [1, 0]
                ];
                
                let kickSuccess = false;
                
                for (let offset of kickOffsets) {
                    currentPiece.row = originalRow + offset[0];
                    currentPiece.col = originalCol + offset[1];
                    
                    if (!checkCollision()) {
                        kickSuccess = true;
                        break;
                    }
                }
                
                // 如果所有牆壁踢嘗試都失敗，恢復原狀
                if (!kickSuccess) {
                    currentPiece.shape = originalShape;
                    currentPiece.row = originalRow;
                    currentPiece.col = originalCol;
                    return false;
                }
            }
            
            return true;
        }
        
        // 移動方塊
        function movePiece(rowOffset, colOffset) {
            if (!currentPiece) return false;
            
            if (!checkCollision(rowOffset, colOffset)) {
                currentPiece.row += rowOffset;
                currentPiece.col += colOffset;
                return true;
            }
            return false;
        }
        
        // 固定方塊到遊戲板
        function lockPiece() {
            if (!currentPiece) return;
            
            const shape = currentPiece.shape;
            
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        const boardRow = currentPiece.row + r;
                        const boardCol = currentPiece.col + c;
                        
                        if (boardRow >= 0) {
                            board[boardRow][boardCol] = currentPieceColor;
                        }
                    }
                }
            }
            
            // 檢查並清除完整的行
            clearLines();
            
            // 創建新方塊
            createPiece();
        }
        
        // 清除完整的行並計算分數
        function clearLines() {
            let linesCleared = 0;
            
            for (let r = ROWS - 1; r >= 0; r--) {
                let isLineComplete = true;
                
                for (let c = 0; c < COLS; c++) {
                    if (!board[r][c]) {
                        isLineComplete = false;
                        break;
                    }
                }
                
                if (isLineComplete) {
                    linesCleared++;
                    
                    for (let row = r; row > 0; row--) {
                        for (let c = 0; c < COLS; c++) {
                            board[row][c] = board[row - 1][c];
                        }
                    }
                    
                    for (let c = 0; c < COLS; c++) {
                        board[0][c] = null;
                    }
                    
                    r++;
                }
            }
            
            if (linesCleared > 0) {
                const points = [0, 40, 100, 300, 1200];
                score += points[linesCleared];
                scoreElement.textContent = score;
                
                // 隨分數提高難度
                if (score > 500 && dropInterval > 200) {
                    dropInterval = Math.max(200, 1000 - Math.floor(score / 500) * 100);
                }
            }
        }
        
        // 方塊直接落下
        function dropPiece() {
            if (!currentPiece) return;
            
            while (movePiece(1, 0)) {}
            
            lockPiece();
            dropStart = Date.now();
        }
        
        // 更新遊戲狀態
        function update() {
            if (!gameRunning || !currentPiece) return;
            
            const now = Date.now();
            const delta = now - dropStart;
            
            if (delta > dropInterval) {
                if (!movePiece(1, 0)) {
                    lockPiece();
                }
                dropStart = now;
            }
            
            draw();
        }
        
        // 遊戲循環
        function gameStep() {
            if (gameRunning) {
                update();
            }
        }
        
        // 開始遊戲
        function startGame() {
            if (gameOver) {
                resetGame();
            }
            
            if (!gameRunning) {
                gameRunning = true;
                updateGameStatus('遊戲中');
                gameLoop = setInterval(gameStep, 50);
            }
        }
        
        // 暫停遊戲
        function pauseGame() {
            if (gameRunning && !gameOver) {
                gameRunning = false;
                updateGameStatus('已暫停');
                clearInterval(gameLoop);
            } else if (!gameRunning && !gameOver) {
                gameRunning = true;
                updateGameStatus('遊戲中');
                gameLoop = setInterval(gameStep, 50);
            }
        }
        
        // 重新開始遊戲
        function resetGame() {
            gameRunning = false;
            gameOver = false;
            score = 0;
            dropInterval = 1000;
            
            scoreElement.textContent = score;
            
            initBoard();
            createPiece();
            updateGameStatus('準備開始');
            
            clearInterval(gameLoop);
            draw();
        }
        
        // 更新遊戲狀態顯示
        function updateGameStatus(status) {
            gameStatusElement.textContent = status;
            gameStatusElement.className = '';
            
            if (status === '遊戲中') {
                gameStatusElement.classList.add('status-playing');
            } else if (status === '已暫停') {
                gameStatusElement.classList.add('status-paused');
            } else if (status === '遊戲結束') {
                gameStatusElement.classList.add('status-gameover');
            } else {
                gameStatusElement.classList.add('status-ready');
            }
        }
        
        // 鍵盤控制
        document.addEventListener('keydown', (e) => {
            if (!gameRunning || gameOver) return;
            
            switch(e.key) {
                case 'ArrowLeft':
                    movePiece(0, -1);
                    break;
                case 'ArrowRight':
                    movePiece(0, 1);
                    break;
                case 'ArrowDown':
                    movePiece(1, 0);
                    break;
                case ' ':
                    dropPiece();
                    break;
                case 'p':
                case 'P':
                    pauseGame();
                    break;
                case 'a':
                case 'A':
                    rotatePiece(false); // 左旋轉（逆時針）
                    break;
                case 'd':
                case 'D':
                    rotatePiece(true); // 右旋轉（順時針）
                    break;
            }
            
            draw();
        });
        
        // 按鈕事件監聽
        startBtn.addEventListener('click', startGame);
        pauseBtn.addEventListener('click', pauseGame);
        restartBtn.addEventListener('click', resetGame);
        rotateLeftBtn.addEventListener('click', () => {
            rotatePiece(false);
            draw();
        });
        rotateRightBtn.addEventListener('click', () => {
            rotatePiece(true);
            draw();
        });
        
        // 初始化遊戲
        resetGame();
    </script>
</body>
</html>