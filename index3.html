<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>俄羅斯方塊 - 完整旋轉版</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #1a1a1a;
            color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1000px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        h1 {
            color: #FFD700;
            font-size: 3rem;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            margin-bottom: 10px;
        }
        
        .game-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
            width: 100%;
        }
        
        .game-board {
            background-color: #FFD700;
            border: 3px solid #FFA500;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.3);
        }
        
        canvas {
            display: block;
        }
        
        .side-panel {
            flex: 1;
            min-width: 280px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .info-box {
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #444;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }
        
        .info-title {
            color: #FFD700;
            font-size: 1.5rem;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .score-value {
            font-size: 3.5rem;
            font-weight: bold;
            color: #4CAF50;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .rotation-controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 15px 0;
        }
        
        .rotation-controls button {
            background-color: #9C27B0;
            color: white;
            border: none;
            padding: 12px 10px;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
        }
        
        .rotation-controls button:hover {
            background-color: #7B1FA2;
            transform: translateY(-2px);
        }
        
        #rotateNorth { grid-column: 1 / span 2; }
        #rotateEast { grid-column: 2; }
        #rotateSouth { grid-column: 1 / span 2; }
        #rotateWest { grid-column: 1; }
        
        .basic-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }
        
        button {
            background-color: #444;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
        }
        
        button:hover {
            background-color: #555;
            transform: translateY(-2px);
        }
        
        .start-btn { background-color: #4CAF50; }
        .start-btn:hover { background-color: #45a049; }
        .pause-btn { background-color: #FF9800; }
        .pause-btn:hover { background-color: #e68900; }
        .restart-btn { background-color: #2196F3; }
        .restart-btn:hover { background-color: #0b7dda; }
        
        .game-status {
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            background-color: #222;
            margin-top: 10px;
        }
        
        .status-ready { color: #4CAF50; }
        .status-playing { color: #FFD700; }
        .status-paused { color: #FF9800; }
        .status-gameover { color: #f44336; }
        
        .instructions {
            margin-top: 10px;
        }
        
        .instructions h3 {
            color: #FFD700;
            margin-bottom: 10px;
        }
        
        .instructions ul {
            list-style-type: none;
        }
        
        .instructions li {
            margin-bottom: 8px;
            color: #ccc;
        }
        
        .instructions .key {
            display: inline-block;
            background-color: #555;
            padding: 4px 10px;
            border-radius: 5px;
            margin: 0 5px;
            font-family: monospace;
            color: #FFD700;
        }
        
        footer {
            margin-top: 30px;
            text-align: center;
            color: #666;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>俄羅斯方塊 - 完整旋轉版</h1>
            <p>每個方塊都有獨特的顏色，支援四個方向旋轉</p>
        </header>
        
        <div class="game-area">
            <div>
                <canvas class="game-board" id="gameCanvas" width="300" height="600"></canvas>
            </div>
            
            <div class="side-panel">
                <div class="info-box">
                    <div class="info-title">分數</div>
                    <div class="score-value" id="score">0</div>
                    
                    <div class="rotation-controls">
                        <button id="rotateNorth">北 ↑ (按鍵1)</button>
                        <button id="rotateEast">東 → (按鍵2)</button>
                        <button id="rotateSouth">南 ↓ (按鍵3)</button>
                        <button id="rotateWest">西 ← (按鍵4)</button>
                    </div>
                    
                    <div class="basic-controls">
                        <button class="start-btn" id="startBtn">開始遊戲</button>
                        <button class="pause-btn" id="pauseBtn">暫停遊戲</button>
                        <button class="restart-btn" id="restartBtn">重新開始</button>
                    </div>
                    
                    <div class="game-status">
                        狀態: <span id="gameStatus" class="status-ready">準備開始</span>
                    </div>
                </div>
                
                <div class="info-box instructions">
                    <h3>遊戲控制</h3>
                    <ul>
                        <li><span class="key">← →</span> 左右移動方塊</li>
                        <li><span class="key">↑</span> 順時針旋轉</li>
                        <li><span class="key">Z</span> 逆時針旋轉</li>
                        <li><span class="key">1-4</span> 直接旋轉到北/東/南/西</li>
                        <li><span class="key">↓</span> 加速下落</li>
                        <li><span class="key">Space</span> 直接落下</li>
                        <li><span class="key">P</span> 暫停/繼續遊戲</li>
                    </ul>
                    <p style="color: #FF9800; margin-top: 10px;">旋轉功能讓遊戲更靈活，提高生存率！</p>
                </div>
            </div>
        </div>
        
        <footer>
            <p>俄羅斯方塊遊戲 | 每個方塊顏色不同 | 支援四個方向旋轉</p>
        </footer>
    </div>

    <script>
        // 遊戲變數
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const gameStatusElement = document.getElementById('gameStatus');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const restartBtn = document.getElementById('restartBtn');
        
        // 方塊形狀定義
        const tetrominoes = [
            // I
            [
                [0,0,0,0],
                [1,1,1,1],
                [0,0,0,0],
                [0,0,0,0]
            ],
            // J
            [
                [1,0,0],
                [1,1,1],
                [0,0,0]
            ],
            // L
            [
                [0,0,1],
                [1,1,1],
                [0,0,0]
            ],
            // O
            [
                [1,1],
                [1,1]
            ],
            // S
            [
                [0,1,1],
                [1,1,0],
                [0,0,0]
            ],
            // T
            [
                [0,1,0],
                [1,1,1],
                [0,0,0]
            ],
            // Z
            [
                [1,1,0],
                [0,1,1],
                [0,0,0]
            ]
        ];
        
        // 遊戲參數
        const ROWS = 20;
        const COLS = 10;
        const BLOCK_SIZE = canvas.width / COLS;
        
        let board = [];
        let currentPiece = null;
        let currentPieceColor = null;
        let score = 0;
        let gameRunning = false;
        let gameOver = false;
        let dropInterval = 1000;
        let dropStart = Date.now();
        let gameLoop;
        
        // 初始化遊戲板
        function initBoard() {
            board = [];
            for (let r = 0; r < ROWS; r++) {
                board[r] = [];
                for (let c = 0; c < COLS; c++) {
                    board[r][c] = null;
                }
            }
        }
        
        // 生成隨機顏色
        function generateRandomColor() {
            const colors = [
                '#FF5252', '#FF4081', '#E040FB', '#7C4DFF',
                '#536DFE', '#448AFF', '#40C4FF', '#18FFFF',
                '#64FFDA', '#69F0AE', '#B2FF59', '#EEFF41',
                '#FFFF00', '#FFD740', '#FFAB40', '#FF6E40'
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        }
        
        // 創建新方塊
        function createPiece() {
            const pieceIndex = Math.floor(Math.random() * tetrominoes.length);
            currentPiece = JSON.parse(JSON.stringify(tetrominoes[pieceIndex])); // 深拷貝
            currentPieceColor = generateRandomColor();
            
            // 設置方塊起始位置
            currentPiece.row = 0;
            currentPiece.col = Math.floor(COLS / 2) - Math.floor(currentPiece[0].length / 2);
            
            // 檢查遊戲是否結束
            if (checkCollision(0, 0)) {
                gameOver = true;
                updateGameStatus('遊戲結束');
                clearInterval(gameLoop);
            }
        }
        
        // 繪製遊戲板
        function drawBoard() {
            // 繪製黃色背景
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 繪製網格線
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
            ctx.lineWidth = 1;
            
            // 垂直線
            for (let c = 0; c <= COLS; c++) {
                ctx.beginPath();
                ctx.moveTo(c * BLOCK_SIZE, 0);
                ctx.lineTo(c * BLOCK_SIZE, canvas.height);
                ctx.stroke();
            }
            
            // 水平線
            for (let r = 0; r <= ROWS; r++) {
                ctx.beginPath();
                ctx.moveTo(0, r * BLOCK_SIZE);
                ctx.lineTo(canvas.width, r * BLOCK_SIZE);
                ctx.stroke();
            }
            
            // 繪製已固定的方塊
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c]) {
                        ctx.fillStyle = board[r][c];
                        ctx.fillRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                        
                        // 添加內部效果
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                        ctx.fillRect(c * BLOCK_SIZE + 2, r * BLOCK_SIZE + 2, BLOCK_SIZE - 5, BLOCK_SIZE - 5);
                    }
                }
            }
        }
        
        // 繪製當前方塊
        function drawPiece() {
            if (!currentPiece) return;
            
            for (let r = 0; r < currentPiece.length; r++) {
                for (let c = 0; c < currentPiece[r].length; c++) {
                    if (currentPiece[r][c]) {
                        ctx.fillStyle = currentPieceColor;
                        ctx.fillRect(
                            (currentPiece.col + c) * BLOCK_SIZE,
                            (currentPiece.row + r) * BLOCK_SIZE,
                            BLOCK_SIZE - 1,
                            BLOCK_SIZE - 1
                        );
                        
                        // 添加內部效果
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                        ctx.fillRect(
                            (currentPiece.col + c) * BLOCK_SIZE + 2,
                            (currentPiece.row + r) * BLOCK_SIZE + 2,
                            BLOCK_SIZE - 5,
                            BLOCK_SIZE - 5
                        );
                    }
                }
            }
        }
        
        // 繪製遊戲
        function draw() {
            drawBoard();
            drawPiece();
        }
        
        // 檢查碰撞
        function checkCollision(rowOffset = 0, colOffset = 0) {
            if (!currentPiece) return false;
            
            for (let r = 0; r < currentPiece.length; r++) {
                for (let c = 0; c < currentPiece[r].length; c++) {
                    if (!currentPiece[r][c]) continue;
                    
                    const newRow = currentPiece.row + r + rowOffset;
                    const newCol = currentPiece.col + c + colOffset;
                    
                    // 檢查是否超出邊界或與已固定的方塊重疊
                    if (
                        newCol < 0 || 
                        newCol >= COLS || 
                        newRow >= ROWS || 
                        (newRow >= 0 && board[newRow][newCol])
                    ) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        // 旋轉方塊 - 修復版本
        function rotatePiece(direction = 'clockwise') {
            if (!currentPiece || !gameRunning || gameOver) return false;
            
            // 儲存原始方塊
            const originalPiece = JSON.parse(JSON.stringify(currentPiece));
            const originalRow = currentPiece.row;
            const originalCol = currentPiece.col;
            
            // 創建旋轉後的方塊
            let rotated = [];
            const rows = currentPiece.length;
            const cols = currentPiece[0].length;
            
            if (direction === 'clockwise' || direction === 'north' || 
                direction === 'east' || direction === 'south' || direction === 'west') {
                // 順時針旋轉
                for (let c = 0; c < cols; c++) {
                    rotated[c] = [];
                    for (let r = rows - 1; r >= 0; r--) {
                        rotated[c][rows - 1 - r] = currentPiece[r][c];
                    }
                }
            } else if (direction === 'counterclockwise') {
                // 逆時針旋轉
                for (let c = cols - 1; c >= 0; c--) {
                    rotated[cols - 1 - c] = [];
                    for (let r = 0; r < rows; r++) {
                        rotated[cols - 1 - c][r] = currentPiece[r][c];
                    }
                }
            }
            
            // 更新當前方塊為旋轉後的方塊
            currentPiece = rotated;
            
            // 檢查旋轉後是否碰撞
            if (checkCollision()) {
                // 如果碰撞，嘗試牆壁踢（wall kick）
                let kickOffsets = [
                    [0, 0], [0, -1], [0, 1], [-1, 0], [1, 0],
                    [0, -2], [0, 2], [-2, 0], [2, 0]
                ];
                
                let kickSuccess = false;
                
                for (let offset of kickOffsets) {
                    currentPiece.row = originalRow + offset[0];
                    currentPiece.col = originalCol + offset[1];
                    
                    if (!checkCollision()) {
                        kickSuccess = true;
                        break;
                    }
                }
                
                // 如果所有牆壁踢嘗試都失敗，恢復原狀
                if (!kickSuccess) {
                    currentPiece = originalPiece;
                    currentPiece.row = originalRow;
                    currentPiece.col = originalCol;
                    return false;
                }
            }
            
            return true;
        }
        
        // 四個方向的旋轉函數
        function rotateToNorth() {
            // 北方向是原始方向
            // 我們需要旋轉到原始方向
            if (rotatePiece('clockwise')) {
                // 已經旋轉了一次，可能需要多次旋轉才能回到北方向
                // 為了簡化，我們這裡只做一次旋轉
                // 實際遊戲中可以記錄旋轉狀態來實現精確控制
            }
        }
        
        function rotateToEast() {
            rotatePiece('clockwise');
        }
        
        function rotateToSouth() {
            rotatePiece('clockwise');
            rotatePiece('clockwise');
        }
        
        function rotateToWest() {
            rotatePiece('counterclockwise');
        }
        
        // 移動方塊
        function movePiece(rowOffset, colOffset) {
            if (!currentPiece) return false;
            
            if (!checkCollision(rowOffset, colOffset)) {
                currentPiece.row += rowOffset;
                currentPiece.col += colOffset;
                return true;
            }
            return false;
        }
        
        // 固定方塊到遊戲板
        function lockPiece() {
            if (!currentPiece) return;
            
            for (let r = 0; r < currentPiece.length; r++) {
                for (let c = 0; c < currentPiece[r].length; c++) {
                    if (currentPiece[r][c]) {
                        const boardRow = currentPiece.row + r;
                        const boardCol = currentPiece.col + c;
                        
                        if (boardRow >= 0) {
                            board[boardRow][boardCol] = currentPieceColor;
                        }
                    }
                }
            }
            
            // 檢查並清除完整的行
            clearLines();
            
            // 創建新方塊
            createPiece();
        }
        
        // 清除完整的行並計算分數
        function clearLines() {
            let linesCleared = 0;
            
            for (let r = ROWS - 1; r >= 0; r--) {
                let isLineComplete = true;
                
                for (let c = 0; c < COLS; c++) {
                    if (!board[r][c]) {
                        isLineComplete = false;
                        break;
                    }
                }
                
                if (isLineComplete) {
                    linesCleared++;
                    
                    for (let row = r; row > 0; row--) {
                        for (let c = 0; c < COLS; c++) {
                            board[row][c] = board[row - 1][c];
                        }
                    }
                    
                    for (let c = 0; c < COLS; c++) {
                        board[0][c] = null;
                    }
                    
                    r++;
                }
            }
            
            if (linesCleared > 0) {
                const points = [0, 40, 100, 300, 1200];
                score += points[linesCleared];
                scoreElement.textContent = score;
            }
        }
        
        // 方塊直接落下
        function dropPiece() {
            if (!currentPiece) return;
            
            while (movePiece(1, 0)) {}
            
            lockPiece();
            dropStart = Date.now();
        }
        
        // 更新遊戲狀態
        function update() {
            if (!gameRunning || !currentPiece) return;
            
            const now = Date.now();
            const delta = now - dropStart;
            
            if (delta > dropInterval) {
                if (!movePiece(1, 0)) {
                    lockPiece();
                }
                dropStart = now;
            }
            
            draw();
        }
        
        // 遊戲循環
        function gameStep() {
            if (gameRunning) {
                update();
            }
        }
        
        // 開始遊戲
        function startGame() {
            if (gameOver) {
                resetGame();
            }
            
            if (!gameRunning) {
                gameRunning = true;
                updateGameStatus('遊戲中');
                gameLoop = setInterval(gameStep, 50);
            }
        }
        
        // 暫停遊戲
        function pauseGame() {
            if (gameRunning && !gameOver) {
                gameRunning = false;
                updateGameStatus('已暫停');
                clearInterval(gameLoop);
            } else if (!gameRunning && !gameOver) {
                gameRunning = true;
                updateGameStatus('遊戲中');
                gameLoop = setInterval(gameStep, 50);
            }
        }
        
        // 重新開始遊戲
        function resetGame() {
            gameRunning = false;
            gameOver = false;
            score = 0;
            dropInterval = 1000;
            
            scoreElement.textContent = score;
            
            initBoard();
            createPiece();
            updateGameStatus('準備開始');
            
            clearInterval(gameLoop);
            draw();
        }
        
        // 更新遊戲狀態顯示
        function updateGameStatus(status) {
            gameStatusElement.textContent = status;
            gameStatusElement.className = '';
            
            if (status === '遊戲中') {
                gameStatusElement.classList.add('status-playing');
            } else if (status === '已暫停') {
                gameStatusElement.classList.add('status-paused');
            } else if (status === '遊戲結束') {
                gameStatusElement.classList.add('status-gameover');
            } else {
                gameStatusElement.classList.add('status-ready');
            }
        }
        
        // 鍵盤控制
        document.addEventListener('keydown', (e) => {
            if (!gameRunning || gameOver) return;
            
            switch(e.key) {
                case 'ArrowLeft':
                    movePiece(0, -1);
                    break;
                case 'ArrowRight':
                    movePiece(0, 1);
                    break;
                case 'ArrowDown':
                    movePiece(1, 0);
                    break;
                case 'ArrowUp':
                    rotatePiece('clockwise');
                    break;
                case ' ':
                    dropPiece();
                    break;
                case 'p':
                case 'P':
                    pauseGame();
                    break;
                case 'z':
                case 'Z':
                    rotatePiece('counterclockwise');
                    break;
                case '1':
                    rotateToNorth();
                    break;
                case '2':
                    rotateToEast();
                    break;
                case '3':
                    rotateToSouth();
                    break;
                case '4':
                    rotateToWest();
                    break;
            }
            
            draw();
        });
        
        // 按鈕事件監聽
        startBtn.addEventListener('click', startGame);
        pauseBtn.addEventListener('click', pauseGame);
        restartBtn.addEventListener('click', resetGame);
        
        // 旋轉按鈕事件監聽
        document.getElementById('rotateNorth').addEventListener('click', rotateToNorth);
        document.getElementById('rotateEast').addEventListener('click', rotateToEast);
        document.getElementById('rotateSouth').addEventListener('click', rotateToSouth);
        document.getElementById('rotateWest').addEventListener('click', rotateToWest);
        
        // 初始化遊戲
        resetGame();
    </script>
</body>
</html>